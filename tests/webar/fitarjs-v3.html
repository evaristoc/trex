<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- three.js library -->
	<script src='../../arjs@v3-resources/three.js/examples/vendor/three.js/build/three.min.js'></script>
	<!-- three.js load GLTF -->
	<script src='../../arjs@v3-resources/three.js/examples/vendor/three.js/GLTFLoader.js'></script>
	<!-- a hack? 
	<script src="../../arjs-resources/threex/threex-artoolkitcontext.js"></script>-->
	<!-- ar.js -->
	<script src='../../arjs@v3-resources/three.js/build/ar-nft.js'></script>

    <script>
      // WebXR requires HTTPS, so the site doesn't work if someone manually enters
      // the URL and ends up using HTTP. To work around this, force redirect from
      // http to https for non-localhost addresses.
      if (window.location.protocol == "http:" &&
          window.location.hostname != "localhost" && 
          window.location.hostname != "127.0.0.1" &&
          window.location.hostname != "[::1]") {
        window.location = window.location.href.replace('http:', 'https:');        
      }
    </script>
	
	    <!-- import the webpage's javascript files -->
    <script src="https://aframe.io/releases/1.0.3/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@3.3.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.1.0/dist/aframe-environment-component.min.js"></script>

    <script>
      // Define a few custom components useful for AR mode. While these are somewhat reusable,
      // I recommend checking if there are officially supported alternatives before copying
      // these into new projects.
    
      // See also https://github.com/aframevr/aframe/pull/4356
      AFRAME.registerComponent('hide-in-ar-mode', {
        // Set this object invisible while in AR mode.
        init: function () {
          this.el.sceneEl.addEventListener('enter-vr', (ev) => {
            //this.wasVisible = this.el.getAttribute('visible');
            //if (this.el.sceneEl.is('ar-mode')) {
            //  this.el.setAttribute('visible', false);
            //}
          });
          //this.el.sceneEl.addEventListener('exit-vr', (ev) => {
          //  if (this.wasVisible) this.el.setAttribute('visible', true);
          //});
		  this.el.sceneEl.addEventListener('enter-ar', (ev) => {
			  scene_ARjs.remove(arToolkitContext._arMarkersControls[0].object3d);
			  arToolkitSource.ready = false;
		  })
        }
      });
      
      AFRAME.registerComponent('ar-shadows', {
        // Swap an object's material to a transparent shadows-only material while
        // in AR mode. Intended for use with a ground plane. The object is also
        // set visible while in AR mode, this is useful if it's hidden in other
        // modes due to them using a 3D environment.
        schema: {
          opacity: {default: 0.3}
        },
        init: function () {
          this.el.sceneEl.addEventListener('enter-vr', (ev) => {
            this.wasVisible = this.el.getAttribute('visible');
            if (this.el.sceneEl.is('ar-mode')) {
              this.savedMaterial = this.el.object3D.children[0].material;
              this.el.object3D.children[0].material = new THREE.ShadowMaterial();
              this.el.object3D.children[0].material.opacity = this.data.opacity;
              this.el.setAttribute('visible', true);
            }
          });
          this.el.sceneEl.addEventListener('exit-vr', (ev) => {
            if (this.savedMaterial) {
              this.el.object3D.children[0].material = this.savedMaterial;
              this.savedMaterial = null;
            }
            if (!this.wasVisible) this.el.setAttribute('visible', false);
          });
        }
      });    
  </script>

  <style>
	  .a-enter-vr{
		display: none;
	  }
	  
  
	  .message{
		position: absolute;
		top: 10%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 300px;
		border: solid 5px steelblue;
		background-color: silver;
		color: white;
		font-size: 15px;
	  }

  </style>

</meta>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
	<!-- LOG AREA -->
	<div id="log" style="background-color:orange; color:white; font-weight: bold; width:200px; z-index:100;">
	    <p id="modified"></p>
		<p id="p1"></p>
		<p id="p2"></p>
		<p id="p3"></p>
		<p id="p4"></p>
		<p id="p5"></p>
	</div>
	<!-- AR.JS SECTION -->
	<div id="arjs" style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
	  </br>
	</div>
	<!--<div class="arjs-loader">
        <div class="arjs-loader-spinner"></div>
    </div>-->

	<div id="ascene">
		<!--<a-scene renderer="antialias: true" vr-mode-ui="enterVRButton: enterARButton: #myEnterARButton">
		  <button type="submit" id="myEnterARButton" href="#" style="font-size: larger; margin-left:100px;">AR</button>
		  <a id="myEnterARButton" href="#">AR</a>-->
		<a-scene renderer="antialias: true">
		  <a-assets timeout="30000">
			<!-- Model source: https://sketchfab.com/3d-models/spinosaurus-2135501583704537907645bf723685e7
				 Model author: https://sketchfab.com/VapTor
				 Model license: CC Attribution -->
			<a-asset-item id="spinosaurus" src="https://cdn.glitch.com/324a5290-5aa7-4efc-92d6-ae0736433b12%2Fspinosaurus.glb" response-type="arraybuffer"></a-asset-item>
		  </a-assets>

		  <a-camera position="0.0 0.0 0.0"></a-camera>

		  <a-entity id="dino" position="0 0 0" rotation="0 0 0">
			<a-entity position="0 1.15 -0.3" 
                  rotation="0 80 0"
                  scale="0.03 0.03 0.03"
                  gltf-model="#spinosaurus"
                  animation-mixer
                  shadow="cast: true; receive: false">
		  </a-entity>
		  </a-entity>
		  <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
		  <a-light type="directional"
			 light="castShadow: true;
					shadowMapHeight: 1024;
					shadowMapWidth: 1024;
					shadowCameraLeft: -7;
					shadowCameraRight: 5;
					shadowCameraBottom: -5;
					shadowCameraTop: 5;"
			 id="light"
			 target="testbox"
			 position="-5 3 1.5"></a-light>
		 </a-scene>
		<div id="text">
		  
		  <div class="message" id="message1">
			Paso 1: Coloque el producto sobre la mesa (aprox. 70cm al piso) y acerque su aparato a la etiqueta.
		  </div>
		  <div class="message" id="message2" hidden>
			Paso 2: El aparato consiguió la marca!! Ahora puede iniciar la sesión de AR mientras mantiene el aparato en esta posición.
		  </div>

		</div>
	</div>

	
	<script>
		
		
		
		alert("Para usar el mode AR de WebXR, use un telefono Android/iOS compatible con arCore con Chrome v79+ y autorize el uso del modulo WebAR en chrome://flags.")
		//////////////////////////////////////////////////////////////////////////////////
		//		Init ARJS!!
		//////////////////////////////////////////////////////////////////////////////////
		
		const lastModifiedDate = new Date(document.lastModified);
		//document.getElementById("modified").textContent = lastModifiedDate;
		
		
		document.getElementsByClassName("a-enter-ar-button").disabled = true;
		// init renderer
		var renderer	= new THREE.WebGLRenderer({
			antialias: true,
			alpha: true,
			precision: 'mediump',
		});
		renderer.setClearColor(new THREE.Color('lightgrey'), 0)
		renderer.setSize( 640, 480 );
		//renderer.setSize( 320, 240 );
		renderer.domElement.style.position = 'absolute'
		renderer.domElement.style.top = '0px'
		renderer.domElement.style.left = '0px'
		document.getElementById("arjs").appendChild( renderer.domElement );
	
		// array of functions for the rendering loop
		var onRenderFcts= [];
	
		// init scene and camera
		var scene_ARjs = new THREE.Scene();
	
		//////////////////////////////////////////////////////////////////////////////////
		//		Initialize a basic camera
		//////////////////////////////////////////////////////////////////////////////////
	
		// Create a camera
		var camera = new THREE.Camera();
		
		scene_ARjs.add(camera);
		
		
	
		////////////////////////////////////////////////////////////////////////////////
		//          handle arToolkitSource
		////////////////////////////////////////////////////////////////////////////////
	
		var arToolkitSource = new THREEx.ArToolkitSource({
			// to read from the webcam
			sourceType : 'webcam',

		})
	
		arToolkitSource.init(function onReady(){
			// open a the dev console
			setTimeout(() => {
				onResize()
			}, 2000);
		})
		
		// handle resize
		window.addEventListener('resize', function(){
			onResize()
		})
	
		function onResize(){
			arToolkitSource.onResizeElement()
			arToolkitSource.copyElementSizeTo(renderer.domElement)
			if( arToolkitContext.arController !== null ){
				arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		//          initialize arToolkitContext
		////////////////////////////////////////////////////////////////////////////////
	
	
		// create atToolkitContext
		var arToolkitContext = new THREEx.ArToolkitContext({
			detectionMode: 'mono',
			
			//required in the new format; no settings in THREEx ArTookitContext separately
			canvasWidth: 480,
            canvasHeight: 640,
        }, {
            sourceWidth: 480,
            sourceHeight: 640,
		})
		// initialize it
		arToolkitContext.init(function onCompleted(){
			// copy projection matrix to camera
			camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		})
	

		////////////////////////////////////////////////////////////////////////////////
		//          Create a ArMarkerControls
		////////////////////////////////////////////////////////////////////////////////
	
		// init controls for camera
		var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
			type: 'nft',
			descriptorsUrl:'https://arjs-cors-proxy.herokuapp.com/https://raw.githack.com/AR-js-org/AR.js/master/aframe/examples/image-tracking/nft/trex/trex-image/trex',
			// as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
			changeMatrixMode: 'cameraTransformMatrix'
		})

		////////////////////////////////////////////////
		/////////////////// OBJ TEST //////////////////
		////////////////////////////////////////////////

	
		// add a torus knot
		var geometry	= new THREE.CubeGeometry(300,300,30);
		var material	= new THREE.MeshNormalMaterial({
			transparent : true,
			opacity: 0.5,
			side: THREE.DoubleSide
		});
		var mesh	= new THREE.Mesh( geometry, material );
		mesh.position.z = 0.0;
		mesh.position.x = 150;
		mesh.position.y = 150;
		scene_ARjs.add( mesh );
	
		var geometry	= new THREE.TorusKnotGeometry(0.3,0.1,64,16);
		var material	= new THREE.MeshNormalMaterial();
		var mesh	= new THREE.Mesh( geometry, material );
		mesh.position.z	= 0.5
		//scene_ARjs.add( mesh );
	
		onRenderFcts.push(function(delta){
			mesh.rotation.x += Math.PI*delta
		})
		
		
		////////////////////////////////////////////////
		/////////////////// ANIMATION //////////////////
		////////////////////////////////////////////////

		var averaging = {x:[],y:[],z:[], max:20};
		var countfoundHiro = 0;
		
		function newScene(averaging) {
	  
		}
		

		// update artoolkit on every frame
		onRenderFcts.push(function(){
			
			
			if( arToolkitSource.ready === false ){
				//document.getElementsByTagName('video').hidden = "false";
				return
			}
			
			/*COLLECTING VALUES*/
			//console.log("camera position before: ", camera.position);
			//document.getElementById('p1').innerHTML = "x: "+String(camera.position.x).slice(0,4) + "; y: "+String(camera.position.y).slice(0,4) + "; z: "+String(camera.position.z).slice(0,4)
			if (Math.abs(camera.position.x) <= 20 & Math.abs(camera.position.y) <= 20  & Math.abs(camera.position.z) <= 20 ) {
			  //code
			  averaging.x.push(camera.position.x);
			  averaging.y.push(camera.position.y);
			  averaging.z.push(camera.position.z);
			}

			averaging.x.push(camera.position.x/1000);
			averaging.y.push(camera.position.y/1000);
			averaging.z.push(camera.position.z/1500);
			
			if (averaging.x.length > averaging.max ) {
				//code
				averaging.x.shift(0);
			};
			if (averaging.y.length > averaging.max ) {
				//code
				averaging.y.shift(0);
			};
			if (averaging.z.length > averaging.max ) {
				//code
				averaging.z.shift(0);
			}
			
			if (arToolkitContext._arMarkersControls[0].object3d.visible){
			  camera.position.x = averaging.x.reduce((a,b)=>{return a+b})/averaging.max + 2 + 250;
			  camera.position.y = averaging.y.reduce((a,b)=>{return a+b})/averaging.max + 250;
			  camera.position.z = averaging.z.reduce((a,b)=>{return a+b})/averaging.max;
			  //console.log("camera position after: ", camera.position);
			  //document.getElementById('p2').innerHTML = "cam-x: "+String(camera.position.x).slice(0,4) + "; ave-y: "+String(camera.position.y).slice(0,4) + "; ave-z: "+String(camera.position.z).slice(0,4)+ " - (sample size: "+averaging.max+")"
			  countfoundHiro += 1;
			  if (countfoundHiro > 20) {
				
				document.getElementById('ascene').style.display = "block";
				document.getElementsByClassName("a-enter-ar-button").disabled = false;
				document.getElementById('message1').hidden = true;
				document.getElementById('message2').hidden = false;
				
				//document.getElementById('ascene').hidden = true;
				//arToolkitSource.domElement.hidden = true;
				//arToolkitSource.ready = false;				
				newScene(averaging);
			  }
			}

	
			arToolkitContext.update( arToolkitSource.domElement )
			
			// update scene_ARjs.visible if the marker is seen
			scene_ARjs.visible = camera.visible
		})
	

	
		//////////////////////////////////////////////////////////////////////////////////
		//		render the whole thing on the page
		//////////////////////////////////////////////////////////////////////////////////
	
		// render the scene
		onRenderFcts.push(function(){
			renderer.render( scene, camera );
		})
	
		// run the rendering loop
		var lastTimeMsec= null
		requestAnimationFrame(function animate(nowMsec){
			// keep looping
			requestAnimationFrame( animate );
			// measure time
			lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
			var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
			lastTimeMsec	= nowMsec
			// call each update function
			onRenderFcts.forEach(function(onRenderFct){
				onRenderFct(deltaMsec/1000, nowMsec/1000)
			})
		})
	</script>
</body>